# Azure Function v2 simple parameter dependency injection

This sample application demonstrates a way to add parameter dependency injection to Azure Functions without relying in attributes.

## Scenario

Build an Azure Function that returns the current part of the day (morning, afternoon, evening, night) based on http://learnersdictionary.com/qa/parts-of-the-day-early-morning-late-morning-etc.

Testing is tricky when dealing with current time. A possible solution is to define a `IDateTimeResolver` that is responsible for returning the current time. While the default implementation returns DateTime.UtcNow, the unit test implementation uses a custom resolver which returns the value we want to test for.

## Function

The function relies on the interface IDateTimeResolver to get the current time.

```C#
/// <summary>
/// Returns the part of the day based on http://learnersdictionary.com/qa/parts-of-the-day-early-morning-late-morning-etc
/// </summary>
[FunctionName(nameof(PartsOfDay))]
public static string Run(
    [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest req, 
    ILogger log,
    IDateTimeResolver dateTimeResolver)
{
    var date = dateTimeResolver.Get();

    if (date.Hour >= 5)
    {
        if (date.Hour < 12)
            return "morning";

        if (date.Hour < 17)
            return "afternoon";

        if (date.Hour < 21)
            return "evening";
    }

    return "night";
}
```

## Tests

Tests will set the current time using a fix implementation of `IDateTimeResolver` to simulate different times.

```C#
 public class PartsOfDayTest
{
    private readonly HttpRequest httpRequest;

    public PartsOfDayTest()
    {
        this.httpRequest = new Mock<HttpRequest>().Object;            
    }

    [Fact]
    public void At_0459_ItIsNight()
    {
        var actual = PartsOfDay.Run(this.httpRequest, NullLogger.Instance, new FixDateTimeResolver(new DateTime(2000, 1, 1, 4, 59, 0, DateTimeKind.Utc)));
        Assert.Equal("night", actual);
    }

    [Fact]
    public void At_0500_ItIsMorning()
    {
        var actual = PartsOfDay.Run(this.httpRequest, NullLogger.Instance, new FixDateTimeResolver(new DateTime(2000, 1, 1, 5, 0, 0, DateTimeKind.Utc)));
        Assert.Equal("morning", actual);
    }
}
```


## Adding Dependency Injection

Azure Functions are build on top of [WebJobs SDK](https://docs.microsoft.com/en-us/azure/app-service/web-sites-create-web-jobs). The Web Jobs SDK provides a way to execute custom code at the startup, including the opportunity to register types in the inversion of control container.

This is possible with the combination of the WebJobsStartupAttribute, the IWebJobsStartup interface and the file bin/extensions.json (generated by Visual Studio) as the code sample below demonstrates:

```C#
[assembly: WebJobsStartup(typeof(DependencyInjectionFunction.Startup))]

namespace DependencyInjectionFunction
{
    /// <summary>
    /// Startup called by WebJob host
    /// </summary>
    public class Startup : IWebJobsStartup
    {
        public void Configure(IWebJobsBuilder builder)
        {
            ConfigureServices(builder.Services);
        }

        void ConfigureServices(IServiceCollection services)
        {
            // Setup custom application DI
            services.AddSingleton<IDateTimeResolver, DateTimeResolver>();                        
        }
    }
}
```

Does it work? What happens when we run the function?

At the function start we already have bad signs:
```bash
[9/12/2018 9:26:34 AM] Error indexing method 'PartsOfDay.Run'
[9/12/2018 9:26:34 AM] Microsoft.Azure.WebJobs.Host: Error indexing method 'PartsOfDay.Run'. Microsoft.Azure.WebJobs.Host: Cannot bind parameter 'dateTimeResolver' to type IDateTimeResolver. Make sure the parameter Type is supported by the binding. If you're using binding extensions (e.g. ServiceBus, Timers, etc.) make sure you've called the registration method for the extension(s) in your startup code (e.g. config.UseServiceBus(), config.UseTimers(), etc.).
```

When invoking the function the following error is raised:
```bash
fail: Microsoft.AspNetCore.Server.Kestrel[13]
      Connection id "0HLGOI7N8NASC", Request id "0HLGOI7N8NASC:00000001": An unhandled exception was thrown by the application.
System.InvalidOperationException: 'PartsOfDay' can't be invoked from Azure WebJobs SDK. Is it missing Azure WebJobs SDK attributes?
   at Microsoft.Azure.WebJobs.JobHost.Validate(IFunctionDefinition function, Object key) in C:\projects\azure-webjobs-sdk-rqm4t\src\Microsoft.Azure.WebJobs.Host\JobHost.cs:line 344
```

Our registered IDateTimeResolver is not automatically injected into the function call. Fortunately we can implement our own [IBindingProvider](https://github.com/Azure/azure-webjobs-sdk-extensions/wiki/The-Binding-Process), allowing the resolution of function parameters values. 

The code below implements a minimal version which provides a value only to parameters without attributes and which the type is an interface. By not providing values to parameter with attributes we won't break existing code that use Cosmos DB, Event Hub and other binding implementations.

```C#
/// <summary>
/// Dependency Injection binding provider
/// Minimal implementation only covering interfaces without any attribute
/// </summary>
public class DependencyInjectionBindingProvider : IBindingProvider
{
    private readonly IServiceProvider serviceProvider;
    private readonly ILogger logger;

    public DependencyInjectionBindingProvider(IServiceProvider serviceProvider, ILogger<DependencyInjectionBindingProvider> logger)
    {
        this.serviceProvider = serviceProvider;
        this.logger = logger;
    }

    public Task<IBinding> TryCreateAsync(BindingProviderContext context)
    {
        if (context == null)
        {
            throw new ArgumentNullException("context");
        }

        var parameter = context.Parameter;            
        if (parameter.ParameterType.IsInterface)
        {
            // Ignore parameters with attributes
            if (parameter.GetCustomAttributes(false).Length == 0)
            {
                var registeredType = serviceProvider.GetService(parameter.ParameterType);
                if (registeredType != null)
                {
                    logger.LogDebug("Implementation for {type} found: {concreteType}", parameter.ParameterType.Name, registeredType.GetType().Name);

                    return Task.FromResult<IBinding>(new DependencyInjectionBinding(parameter.Name, parameter.ParameterType, registeredType));
                }
                else
                {
                    logger.LogDebug("Implementation for {type} not found. Did you registers in the IServiceCollection", parameter.ParameterType.Name);
                }
            }           
        }

        return Task.FromResult<IBinding>(null);
    }
}
```

The binding provider registration happens in the WebJobs startus, the same way we did for the DateTimeResolver:

```C#
void ConfigureServices(IServiceCollection services)
{
    // Setup the Dependency Injection Handler
    services.AddSingleton<IBindingProvider, DependencyInjectionBindingProvider>();

    // Setup custom application DI
    services.AddSingleton<IDateTimeResolver, DateTimeResolver>();                        
}
```

Does it work? Yes! Running the Azure Function won't raise any error during the startup and it returns the expected value when executed:
```bash
$ curl http://localhost:7071/api/PartsOfDay
morning
```

The sample project has another function using CosmosDB bindings, demonstrating that the provided dependency injection won't break existing bindings:

```C#
[FunctionName(nameof(NightlyLog))]
public static async Task<IActionResult> RunAsync(
    [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] string logContent,
    [CosmosDB(databaseName: "functionTest",
    collectionName: "nightLogs",
    CreateIfNotExists = true,
    CollectionThroughput = 400,            
    ConnectionStringSetting = "CosmosDBConnectionString")]
    IAsyncCollector<LogDocument> output,
    IDateTimeResolver dateTimeResolver,
    ILogger log)
{
    var date = dateTimeResolver.Get();

    // only log what happens during the night
    if (date.Hour >= 21 || date.Hour < 5)
    {
        await output.AddAsync(new LogDocument { Log = logContent });
    }

    return new OkResult();            
}
```

## Troubleshooting

- Function works locally, but it returns 500 when deployed to Azure  
Publishing from Visual Studio seems to be broken when definining a WebJobsStartup in the function project. The generated extensions.json does not have the ```{ "name": "DependencyInjectionFunctionStartup", "typeName":"DependencyInjectionFunction.Startup, DependencyInjectionFunction, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null"}```.
When running from Visual Studio (F5) the generated extensions.json file contains the startup information.
